---
title: æ•°ç»„ Array (medium)
date: 2022-12-11 21:00:00
updated: 2022-12-11 23:00:00
tag:
- leetcode
---

## æœ¬ç« é‡ç‚¹

1. é’ˆå¯¹åŸé¢˜ä¸­çš„`O(log(m+n))`æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Œåº”è¯¥æƒ³åˆ°äºŒåˆ†æŸ¥æ‰¾ï¼ˆ[å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„ä¸­çš„ä¸­ä½æ•°](#find_mid)ï¼‰ã€‚

## æœ¬ç« é¢˜ç›®æ€è·¯è®°å¿†è¦ç‚¹

1. **ä¸¤æ•°ç›¸åŠ **ï¼šå‚¨å­˜

## é¢˜ç›®

### 4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° <a name="find_mid">ğŸ“Œ</a>

> ç»™å®šä¸¤ä¸ªå¤§å°åˆ†åˆ«ä¸º `m` å’Œ `n` çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„ `nums1` å’Œ `nums2`ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ **ä¸­ä½æ•°** ã€‚
>
> ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º `O(log (m+n))` ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2]
> è¾“å‡ºï¼š2.00000
> è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums1 = [1,2], nums2 = [3,4]
> è¾“å‡ºï¼š2.50000
> è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3,4] ï¼Œä¸­ä½æ•° (2 + 3) / 2 = 2.5 
> ```
>
> **æç¤ºï¼š**
>
> - `nums1.length == m`
> - `nums2.length == n`
> - `0 <= m <= 1000`
> - `0 <= n <= 1000`
> - `1 <= m + n <= 2000`
> - `-10^6 <= nums1[i], nums2[i] <= 10^6`

acceptç­”æ¡ˆï¼š

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        '''
        æ€è·¯ï¼šä»å¤æ‚åº¦æ–¹é¢è€ƒè™‘ï¼Œä¸å¯ä»¥å…¨éƒ¨æ‰«æï¼Œè¿™ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(m+n)
        è¿™é‡Œè€ƒè™‘ï¼šç”¨ä¸€ä¸ªæ ˆæ¥é¡ºåºå­˜å‚¨åˆå¹¶æ•°ç»„ï¼Œæ ˆçš„å¤§å°ä¸º
        (m+n)/2 -> (m+n)%2 == 0
        (m+n-1)/2 -> (m+n)%2 != 0
        '''
        ordered = []
        pin1, pin2 = 0, 0
        m, n = len(nums1), len(nums2)
        length = (m+n-1)/2 if (m+n)%2 != 0 else (m+n)/2
        while len(ordered) < length+1:
            if pin1 < m and pin2 < n and nums1[pin1] <= nums2[pin2]:
                # ç›¸ç­‰çš„æ—¶å€™åªæ”¾è¿›å»ä¸€ä¸ª
                ordered.append(nums1[pin1])
                pin1 += 1
            elif pin1 < m and pin2 < n:
                ordered.append(nums2[pin2])
                pin2 += 1
            else:
                # æŒ‡é’ˆæœ‰ä¸€ä¸ªä¸åœ¨èŒƒå›´äº†
                if pin1 >= m and pin2 < n:
                    ordered.append(nums2[pin2])
                    pin2 += 1
                elif pin1 < m and pin2 >= n:
                    ordered.append(nums1[pin1])
                    pin1 += 1
                else:
                    break
        if (m+n)%2 == 0:
            return (ordered[-1] + ordered[-2])/2
        else:
            return ordered[-1]
```

é’ˆå¯¹åŸé¢˜ä¸­çš„`O(log(m+n))`æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Œåº”è¯¥æƒ³åˆ°äºŒåˆ†æŸ¥æ‰¾
